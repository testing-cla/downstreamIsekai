#ifndef ISEKAI_HOST_FALCON_RUE_FORMAT_BNA_H_
#define ISEKAI_HOST_FALCON_RUE_FORMAT_BNA_H_

#include <cstdint>

#include "isekai/host/falcon/falcon.h"
#include "isekai/host/falcon/rue/bits.h"
#include "isekai/host/falcon/rue/constants.h"

namespace falcon_rue {

// The comment above a variable refers to the name for the field in Falcon MAS.
// Changes from DNA_C:
// - Added ncwnd_frac for NIC cwnd pacing.
// - Added plb_state as a separate field.
// - Added is_ipv4, multipath_enable and flow_label for multi-pathing.
// - Added csig_enable and csig for CSIG.
// - Removed fipg, retx_to and ncwnd_dir.
// - Increased retx_count width from 3 to 8 bits.
// - Increased cc_opaque width from 2 to 18 bits.
// - Decreased cc_metadata bits from 24 to 22.
struct __attribute__((packed)) Event_BNA {
  // cid
  uint32_t connection_id : kConnectionIdBits;
  // event_type
  falcon::RueEventType event_type : kEventTypeBits;
  // t1
  uint32_t timestamp_1 : kTimeBits;
  // t2
  uint32_t timestamp_2 : kTimeBits;
  // t3
  uint32_t timestamp_3 : kTimeBits;
  // t4
  uint32_t timestamp_4 : kTimeBits;
  // global_rx_req_buf_level
  uint8_t rx_buffer_level : kRxBufferLevelBits;
  // Set if the event was generated by an EACK packet.
  bool eack : 1;
  // nack_code
  falcon::NackCode nack_code : kNackCodeBits;
  // ===== 16 byte boundary =====
  // forward_hops
  uint8_t forward_hops : kForwardHopsBits;
  // retx_count
  uint8_t retransmit_count : kBnaRetransmitCountBits;
  // retx_reason
  falcon::RetransmitReason retransmit_reason : kRetransmitReasonBits;
  // Set if a drop is detected based on the received bitmap in EACK packet.
  bool eack_drop : 1;
  // eack_own bits
  uint8_t eack_own : kEackOwnBits;
  // cc_meta
  uint32_t cc_metadata : kCcMetadataBits;
  // fcwnd_frac (10b) and fcwnd (11b) concatenated
  uint32_t fabric_congestion_window : kFabricCongestionWindowBits;
  // ncwnd_frac (10b) and ncwnd (11b) concatenated
  uint32_t nic_congestion_window : kBnaNicCongestionWindowBits;
  bool is_ipv4 : 1;
  bool multipath_enable : 1;
  // flow_label from ipv6 header or udp header src_port for ipv4.
  uint32_t flow_label : kFlowLabelBits;
  // cc_opaque
  uint32_t cc_opaque : kBnaCcOpaqueBits;
  // ===== 16 byte boundary =====
  // window_guard
  uint32_t fabric_window_time_marker : kTimeBits;
  // ncwnd_guard
  uint32_t nic_window_time_marker : kTimeBits;
  // delay_base
  uint32_t base_delay : kTimeBits;
  // delay_state
  uint32_t delay_state : kTimeBits;
  // plb_state
  uint32_t plb_state : kPlbStateBits;
  // delay_sel
  falcon::DelaySelect delay_select : kDelaySelectBits;
  // event_q_sel
  uint8_t event_queue_select : kEventQueueSelectBits;
  uint8_t reserved_0 : 4;  // For future expansion of event queues if required.
  // ===== 16 byte boundary =====
  // smoothed_rtt
  uint32_t rtt_state : kTimeBits;
  // ecn accumulated
  uint16_t ecn_accumulated : kEcnAccumulatedBits;
  // num_acked
  uint16_t num_packets_acked : kNumPacketsAckedBits;
  // csig
  bool csig_enable : 1;
  uint16_t csig : kCsigBits;
  uint64_t reserved_1 : 62;
  // gen
  uint8_t gen_bit : 1;
};

// - Added ncwnd_frac and nipg for nic cwnd pacing.
// - Added plb_state as a separate field.
// - Added ar_rate.
// - Added flow_{label,label_valid,weights} and wrr_restart_round for Katy-lite.
// - Added csig_enable and csig_sel for CSIG.
// - Added alpha_request and alpha_response for Hawees.
// - Removed randomized_path and ncwnd_dir.
// - Increased cc_opaque width from 2 to 18 bits.
// - Decreased cc_metadata bits from 24 to 22.
struct __attribute__((packed)) Response_BNA {
  // cid
  uint32_t connection_id : kConnectionIdBits;
  // fcwnd_frac and fcwnd concatenated
  uint32_t fabric_congestion_window : kFabricCongestionWindowBits;
  // fipg
  uint32_t inter_packet_gap : kInterPacketGapBits;
  // ncwnd_frac and ncwnd concatenated
  uint32_t nic_congestion_window : kBnaNicCongestionWindowBits;
  // nipg
  uint32_t nic_inter_packet_gap : kInterPacketGapBits;
  // cc_meta
  uint32_t cc_metadata : kCcMetadataBits;
  // ===== 16 byte boundary =====
  // Hawees TX isolation parameters.
  uint8_t alpha_request : kPerConnectionBackpressureAlphaBits;
  uint8_t alpha_response : kPerConnectionBackpressureAlphaBits;
  // window_guard
  uint32_t fabric_window_time_marker : kTimeBits;
  // ncwnd_guard
  uint32_t nic_window_time_marker : kTimeBits;
  // delay_base
  uint32_t base_delay : kTimeBits;
  // delay_state
  uint32_t delay_state : kTimeBits;
  // plb_state
  uint32_t plb_state : kPlbStateBits;
  // cc_opaque
  uint32_t cc_opaque : kBnaCcOpaqueBits;
  // delay_sel
  falcon::DelaySelect delay_select : kDelaySelectBits;
  // ar_rate
  uint8_t ar_rate : kArRateBits;
  // smoothed_rtt
  uint32_t rtt_state : kTimeBits;
  // flow_label[3:0]
  uint32_t flow_label_1 : kFlowLabelBits;
  uint32_t flow_label_2 : kFlowLabelBits;
  uint32_t flow_label_3 : kFlowLabelBits;
  uint32_t flow_label_4 : kFlowLabelBits;
  // flow_label_weight[3:0]
  uint8_t flow_label_1_weight : kFlowLabelWeightBits;
  uint8_t flow_label_2_weight : kFlowLabelWeightBits;
  uint8_t flow_label_3_weight : kFlowLabelWeightBits;
  uint8_t flow_label_4_weight : kFlowLabelWeightBits;
  // flow_label_valid[3:0]
  bool flow_label_1_valid : 1;
  bool flow_label_2_valid : 1;
  bool flow_label_3_valid : 1;
  bool flow_label_4_valid : 1;
  // wrr_restart_round
  bool wrr_restart_round : 1;
  // flow_id
  uint8_t flow_id : kFlowIdBits;
  // csig
  bool csig_enable : 1;
  uint8_t csig_select : kCsigSelectBits;
  // retx_to
  uint32_t retransmit_timeout : kTimeBits;
  // event_q_sel
  uint8_t event_queue_select : kEventQueueSelectBits;
  uint64_t padding_0 : 11;
  uint64_t padding_1 : 64;
};

static_assert(sizeof(Event_BNA) == ABSL_CACHELINE_SIZE,
              "Event is not one cache line :(");
static_assert(sizeof(Response_BNA) == ABSL_CACHELINE_SIZE,
              "Response is not one cache line :(");

}  // namespace falcon_rue

#endif  // ISEKAI_HOST_FALCON_RUE_FORMAT_BNA_H_
